import { Controller } from "@hotwired/stimulus"

export default class extends Controller {
  static targets = [
    "title", "slug", "startTime", "endTime", "freeTicket", "paidTicket",
    "priceField", "priceInput", "privateCheck", "accessCodeField", "accessCodeInput",
    "venueSelect", "venueForm", "venueName", "venueAddress", "venueCity", "venueRegion",
    "venuePhone", "venueCapacity", "recurrenceType", "recurrencePatternField",
    "imageInput", "imagePreview", "mainImageDropzone"
  ]

  connect() {
    // Initialize drag and drop for image upload
    this.initializeDragAndDrop()

    // Initialize datepickers if needed
    this.initializeStartTime()

    // Initialize form validation
    this.addFormValidation()
  }

  initializeStartTime() {
    // Set minimum date for start time to today if it's a new event
    if (this.startTimeTarget.value === "") {
      const today = new Date()
      today.setMinutes(today.getMinutes() - today.getTimezoneOffset())

      // Format for datetime-local input
      const formattedDate = today.toISOString().slice(0, 16)
      this.startTimeTarget.value = formattedDate

      // Set end time to 2 hours after start time
      const endTime = new Date(today)
      endTime.setHours(endTime.getHours() + 2)
      this.endTimeTarget.value = endTime.toISOString().slice(0, 16)
    }
  }

  validateDates() {
    const startDate = new Date(this.startTimeTarget.value)
    const endDate = new Date(this.endTimeTarget.value)

    if (endDate <= startDate) {
      this.endTimeTarget.setCustomValidity("End time must be after start time")
      this.endTimeTarget.reportValidity()
    } else {
      this.endTimeTarget.setCustomValidity("")
    }
  }

  updateSlug() {
    // Only update slug if it's empty or auto-generated
    if (this.slugTarget.value === "" || this.slugTarget.dataset.autoGenerated === "true") {
      const title = this.titleTarget.value
      this.slugTarget.value = this.generateSlug(title)
      this.slugTarget.dataset.autoGenerated = "true"
    }
  }

  generateSlug(text) {
    return text.toString().toLowerCase()
      .replace(/\s+/g, '-')        // Replace spaces with -
      .replace(/[^\w\-]+/g, '')    // Remove all non-word characters
      .replace(/\-\-+/g, '-')      // Replace multiple - with single -
      .replace(/^-+/, '')          // Trim - from start of text
      .replace(/-+$/, '')          // Trim - from end of text
  }

  togglePriceField() {
    if (this.freeTicketTarget.checked) {
      this.priceFieldTarget.classList.add("hidden")
      this.priceInputTarget.value = "0"
      this.priceInputTarget.required = false
    } else {
      this.priceFieldTarget.classList.remove("hidden")
      this.priceInputTarget.value = ""
      this.priceInputTarget.required = true
    }
  }

  toggleAccessCode() {
    if (this.privateCheckTarget.checked) {
      this.accessCodeFieldTarget.classList.remove("hidden")
      this.accessCodeInputTarget.required = true
    } else {
      this.accessCodeFieldTarget.classList.add("hidden")
      this.accessCodeInputTarget.required = false
    }
  }

  toggleRecurrencePattern() {
    if (this.recurrenceTypeTarget.value === "4") { // Custom recurrence
      this.recurrencePatternFieldTarget.classList.remove("hidden")
    } else {
      this.recurrencePatternFieldTarget.classList.add("hidden")
    }
  }

  showNewVenueForm() {
    this.venueFormTarget.classList.remove("hidden")
    this.venueSelectTarget.value = ""
  }

  hideVenueForm() {
    this.venueFormTarget.classList.add("hidden")
    this.venueSelectTarget.selectedIndex = 0
  }

  toggleVenueForm() {
    if (this.venueSelectTarget.value === "new") {
      this.venueFormTarget.classList.remove("hidden")
    } else {
      this.venueFormTarget.classList.add("hidden")
    }
  }

  createVenue(event) {
    event.preventDefault()

    // Validate required fields
    if (!this.venueNameTarget.value || !this.venueAddressTarget.value || !this.venueCityTarget.value) {
      alert("Please fill in all required venue fields")
      return
    }

    // You would normally submit this via fetch/AJAX
    // For this implementation, we'll create an option in the select dropdown
    const newOption = document.createElement("option")
    newOption.text = this.venueNameTarget.value
    newOption.value = `new_venue_${Date.now()}` // Temporary ID
    this.venueSelectTarget.add(newOption, 0)
    this.venueSelectTarget.selectedIndex = 0

    // Hide the venue form
    this.venueFormTarget.classList.add("hidden")

    // Show confirmation message
    const confirmationDiv = document.createElement("div")
    confirmationDiv.className = "mt-2 p-2 bg-green-50 dark:bg-green-900 text-green-700 dark:text-green-300 text-sm rounded"
    confirmationDiv.textContent = `New venue "${this.venueNameTarget.value}" will be created when you save the event`

    const parentElement = this.venueSelectTarget.parentElement
    parentElement.appendChild(confirmationDiv)

    // Remove the confirmation after 5 seconds
    setTimeout(() => {
      if (parentElement.contains(confirmationDiv)) {
        parentElement.removeChild(confirmationDiv)
      }
    }, 5000)
  }

  previewImages() {
    const files = this.imageInputTarget.files

    if (!files || files.length === 0) return

    // Clear previous previews
    this.imagePreviewTarget.innerHTML = ""

    // Create container
    const previewContainer = document.createElement("div")
    previewContainer.className = "grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-4 mt-4"

    for (let i = 0; i < files.length; i++) {
      const file = files[i]

      // Skip non-image files or invalid files
      if (!file || !file.type || !file.type.startsWith("image/")) {
        console.warn("Skipping invalid file:", file)
        continue
      }

      const reader = new FileReader()

      reader.onload = (e) => {
        const preview = document.createElement("div")
        preview.className = "relative group"

        const img = document.createElement("img")
        img.src = e.target.result
        img.alt = "Image preview"
        img.className = "h-32 w-full object-cover rounded-md"

        const removeButton = document.createElement("div")
        removeButton.className = "absolute inset-0 bg-black bg-opacity-40 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity"
        removeButton.innerHTML = `
          <button type="button" class="text-white bg-red-600 hover:bg-red-700 p-2 rounded-full" data-index="${i}">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
              <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
            </svg>
          </button>
        `

        // Add "featured" label if it's the first image
        if (i === 0) {
          const featuredBadge = document.createElement("div")
          featuredBadge.className = "absolute top-0 right-0 bg-blue-600 text-white text-xs px-2 py-1 rounded-bl-md rounded-tr-md"
          featuredBadge.textContent = "Featured"
          preview.appendChild(featuredBadge)
        }

        preview.appendChild(img)
        preview.appendChild(removeButton)

        previewContainer.appendChild(preview)

        // Add click handler for remove button
        removeButton.querySelector("button").addEventListener("click", (evt) => {
          const index = parseInt(evt.currentTarget.dataset.index)
          this.removeImagePreview(index)
        })
      }

      reader.readAsDataURL(file)
    }

    this.imagePreviewTarget.appendChild(previewContainer)
  }

  removeImagePreview(index) {
    // We can't directly remove a file from the FileList, so we need to create a new input
    const currentFiles = this.imageInputTarget.files
    const newFileList = new DataTransfer()

    for (let i = 0; i < currentFiles.length; i++) {
      if (i !== index) {
        newFileList.items.add(currentFiles[i])
      }
    }

    this.imageInputTarget.files = newFileList.files

    // Refresh the preview
    this.previewImages()
  }

  initializeDragAndDrop() {
    const dropzone = this.mainImageDropzoneTarget

    // Prevent default behavior for these events
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
      dropzone.addEventListener(eventName, (e) => {
        e.preventDefault()
        e.stopPropagation()
      }, false)
    })

    // Add visual feedback
    dropzone.addEventListener('dragenter', () => {
      dropzone.classList.add('bg-blue-50', 'dark:bg-blue-900/30')
    }, false)

    dropzone.addEventListener('dragleave', () => {
      dropzone.classList.remove('bg-blue-50', 'dark:bg-blue-900/30')
    }, false)

    // Handle the drop
    dropzone.addEventListener('drop', (e) => {
      dropzone.classList.remove('bg-blue-50', 'dark:bg-blue-900/30')

      const dt = e.dataTransfer
      const files = dt.files

      // Update the file input with the dropped files
      const newFileList = new DataTransfer()

      // Add existing files
      if (this.imageInputTarget.files.length > 0) {
        for (let i = 0; i < this.imageInputTarget.files.length; i++) {
          newFileList.items.add(this.imageInputTarget.files[i])
        }
      }

      // Add new files
      for (let i = 0; i < files.length; i++) {
        // Check if the file is valid and is an image
        if (files[i] && files[i].type && files[i].type.startsWith('image/')) {
          newFileList.items.add(files[i])
        } else {
          console.warn("Skipping invalid file during drag and drop:", files[i])
        }
      }

      this.imageInputTarget.files = newFileList.files

      // Trigger preview update
      this.previewImages()
    }, false)
  }

  addFormValidation() {
    const form = this.element.closest('form')

    form.addEventListener('submit', (event) => {
      // Validate required fields
      let isValid = true

      // Validate dates
      const startDate = new Date(this.startTimeTarget.value)
      const endDate = new Date(this.endTimeTarget.value)

      if (endDate <= startDate) {
        this.endTimeTarget.setCustomValidity("End time must be after start time")
        isValid = false
      } else {
        this.endTimeTarget.setCustomValidity("")
      }

      // Validate price for paid events
      if (this.paidTicketTarget.checked && (!this.priceInputTarget.value || parseFloat(this.priceInputTarget.value) <= 0)) {
        this.priceInputTarget.setCustomValidity("Please enter a valid price greater than 0")
        isValid = false
      } else {
        this.priceInputTarget.setCustomValidity("")
      }

      // Validate access code for private events
      if (this.privateCheckTarget.checked && !this.accessCodeInputTarget.value) {
        this.accessCodeInputTarget.setCustomValidity("Access code is required for private events")
        isValid = false
      } else {
        this.accessCodeInputTarget.setCustomValidity("")
      }

      // If any validations fail, prevent form submission
      if (!isValid) {
        event.preventDefault()

        // Report the first invalid field
        const invalidField = form.querySelector(":invalid")
        if (invalidField) {
          invalidField.reportValidity()
          invalidField.focus()
        }
      }
    })
  }
}
